digraph GC {
	label = "Coop GC State Machine";
	labelloc = "t"
	remincross = true;
	
	// Thread states
	Starting [shape=diamond];
	subgraph cluster_Unsafe {
		label = "Unsafe (for GC to run)" ;
		labelloc = "b";
		node [color = red];
		color = maroon;
		style = solid;
		Running ;
		Async_Suspend_Requested ;
	} ;
	subgraph cluster_Safe {
		labelloc = "b";
		label = "Safe (for GC to run)" ;
		node [color = blue];
		color = blue;
		style = solid;
		Blocking ;
		subgraph cluster_Suspended {
			label = "" ;
			style = invis;
			node [shape = "rectangle", style = "filled", fillcolor = "grey95"];
			
			Async_Suspended ;
			Self_Suspended ;
			Blocking_and_Suspended;
		};
	} ;
		
	Detached [shape=diamond] ;

	// attach
	{
		edge [label = "attach", color="slategrey", fontcolor="slategrey"];
		Starting -> Running;
	}
	// detach
	{
		edge [label = "detach", color="slategrey", fontcolor="slategrey"];
		{ Running Blocking } -> Detached ;
		Async_Suspend_Requested:s -> Async_Suspend_Requested:s;
	}
	

	// do blocking
	{
		edge [label = "do_B", color = "green", fontcolor="darkgreen"];
		Running:ne -> Blocking:nw;
		Async_Suspend_Requested:w -> Async_Suspend_Requested:w [label = "do_B(poll)"];
	}
	
	// abort blocking
	{
		edge [label = "abort_B", color = "goldenrod", fontcolor="goldenrod"];
		Running:w -> Running:w [label="abort_B(ignore)"];
		Async_Suspend_Requested:w -> Async_Suspend_Requested:w [label="abort_B(poll+ignore)"];
		Blocking -> Running [label = "abort_B (susp=0)", constraint = false];
		Blocking -> Blocking_and_Suspended [label = "abort_B\n(susp>0)"];
	}

	// done blocking
	{
		edge [label = "done_B", color = "blue", fontcolor="blue"];
		Blocking -> Running [label = "done_B (susp = 0)", constraint = false]
		Blocking -> Blocking_and_Suspended [ label = "done_B\n(susp > 0)"];
	}

	// request_async_suspension
	{
		edge [label = "req_A_s", color="plum", fontcolor="plum"];
		{ Running } -> Async_Suspend_Requested;
		Async_Suspended:s -> Async_Suspended:s;
		Self_Suspended:s -> Self_Suspended:s;
		Blocking_and_Suspended:s -> Blocking_and_Suspended:s;
		Blocking:s -> Blocking:s;
	}
	
	// poll
	{
		edge [label = "poll", color="indigo", fontcolor="indigo"];
		Running:s -> Running:s;
		Async_Suspend_Requested -> Self_Suspended;
	}

	// resume, just the non-error cases that don't alter the suspend count.
	{
		edge [label ="resume\n(susp=0)" style = "dotted"];
		{ Async_Suspended Self_Suspended Blocking_and_Suspended } -> Running;
	}

	// resume, decrement susp
	{
		edge [label = "resume(decr(susp>1))", style = "dotted", color="slategrey"]
		Async_Suspended -> Async_Suspended;
		Self_Suspended -> Self_Suspended;
		Blocking_and_Suspended -> Blocking_and_Suspended;
		Blocking -> Blocking [ label = "resume(decr(susp>0))"  ];
	}

	// finish_async_suspend
	{
		edge [label = "fin_A_s", color="violet", fontcolor="purple"];
		Self_Suspended:s -> Self_Suspended:s;
		Blocking_and_Suspended:s -> Blocking_and_Suspended:s;
		Async_Suspend_Requested -> Async_Suspended;
        }

}
